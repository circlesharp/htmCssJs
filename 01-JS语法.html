<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>01-JS语法</title>
</head>
<body>
<!-- JS之变量 -->
    <script>
        /* 
        如果省略 var声明 的变量是全局变量
        不推荐使用全局变量 
        */

        // 声明保存用户名的变量
        var name_01;
        name_01 = "marry";
        // 声明保存年龄的变量
        var age = 18;  // 声明的同时赋值

        // 一次声明多个变量
        var name_01="marry", 
            age=18,
            email='marry@qq.com',
            address ;  // 声明多个变量的时候，也可以不赋值。
        
        console.log("===============");
    </script>

<!-- JS之数据类型 -->
    <script>
        /*
        ECMAScript的数据类型
            1. 简单数据类型
                Undefined
                Null
                Boolean
                Number
                String
            2. 复杂数据类型
                Object
        */

        // typeof: 检测变量类型
        // 用法：typeof 变量  或  typeof(变量)
        // 返回：string类型
        console.log(name_01);  // console.log 在控制台中打印
        console.log(typeof name_01);
        console.log(typeof(age));

        // undefined 从 null 派生出来。
        // 所以， undefined == null -> true。
        // null值表示一个空对象指针。
        console.log(typeof(address),typeof(abc));  // 默认都是 undefined
        var settings = null;  // 如果定义的变量准备在将来用于保存对象，最好初始化为 null
        console.log(typeof(settings));  // 结果是 object

        // number 表示整数和浮点数
        // NaN(Not a Number), 它的类型就是 number 。
        // 任何涉及 NaN 的运算都返回 NaN
        // NaN 和任何值都不相等，包括它本身
        // isNaN(n) -> 检测n是否为一个非数值
        console.log(age-15);
        console.log(age-name_01);  // NaN
        console.log(typeof(age-name_01));  // number
        console.log(NaN == NaN);
        console.log(isNaN(age), isNaN("16"), isNaN(email));  // 弱类型

        // 数值转换
        // Number()，不太推荐强制转化
        // parseInt(), 接受两个参数，后一个参数为进制
        // parseFloat()
        console.log(typeof('16'),               // string
                    typeof(Number('16')),
                    parseInt('16'),             // 16
                    typeof(parseInt('16')),     // number
                    parseFloat('16'),           // 16
                    typeof(parseFloat('16')));  // number
        
        var topValue = '28px', soop = 'akb48';
        console.log(parseInt(topValue), parseInt(soop));  // number NaN ; parseInt 提取的内容必须数字开头。
        console.log(parseInt('12.34px'), parseFloat('12.34.px'), parseFloat('12.34.56'));  // 12 12.34 12.34

        // string
        // -> sth.toString()  一个方法，这个sth不能是 null, undefined
        // -> Strig(sth)      一个函数，将任何类型的数据转为字符串
        console.log(age.toString(), String(address));

        // boolean
        // false -> 0, '', undefined, null, NaN
        console.log(Boolean(NaN), Boolean(null), Boolean(undefined));

        console.log("===============");
    </script>

<!-- JS之表达式与操作符 -->
    <script>
        /* 
        表达式：将通类型的数据用运算符号按一定规则连接起来、有意义的式子。（如：运算，比较）
        操作符分类
            1. 算术操作符 
                -> +， -， *， /， %， ++，--
                -> 返回的都是 number, 连 NaN 也是 number
            2. 逻辑操作符 -> 与、或、非
                -> && …… 正义使者：倾向于找假的
                -> || …… 好心人：倾向于找真的
                -> !  …… 布尔兄弟：只返回布尔值
            3. 赋值操作符
                -> 简单赋值：=
                -> 复合赋值：+=, -=, *=, /=, %=
            4. 比较操作符, return boolean
                -> ==   相等：值相对，不要求类型
                -> ===  全等：值相等 & 类型相等
            5. 三元操作符 -> 可替代简单的if语句
                -> statement ? do_sth_1 : do_sth_2
        */

        // 算术操作符
        var num1 = 10, num2 = 20;
        console.log(num1+num2, num1-num2, num1*num2, num1/num2, num1%num2);
        console.log(num1 * "c");  // NaN
        console.log(num1 * "5");  // 弱类型：隐式类型转换

        // ++a 与 a++ 都是对a的递增操作（即 a = a + 1)
        // ++a先返回递增之后a的值；（影响表达式结果）
        // a++先返回a的原值，在返回递增之后的值 （不影响表达式）
        num3 = num1++-5;
        console.log(num1, num3);  // 11, 5
        num1 = 10; num4 = ++num1-5;
        console.log(num1, num4);  // 11, 6 -> 表达式已被 ++a 影响
        console.log(num1++, num1, ++num1, num1); // 表达式不被 a++ 影响，却被 ++a 影响

        // 比较操作符
        console.log(11=='11', 11==='11', 11!='11', 11!=='11');  // true, false, false, true
        console.log(null==undefined, null===undefined)  // true, false

        // 三元操作符
        var sorce = 85;
        var result = (sorce>60) ? "pass" : "fail"
        console.log(result)  // "pass"

        // 逻辑操作符
        // &&（与）-> && 的逻辑是：当存在不是布尔值
        //                          -> 前一个数为真：返回第二个操作数的值
        //                          -> 前一个数为假：返回第一个操作数的值
        //                          -> 倾向于找假的，一找到马上返回，找不到就返回最后一个。
        //                          -> 为 NaN, undefined, null：就返回 NaN, undefined, null
        console.log(2>1&&3, 7&&"some", 0&&"", ""&&0, 22*'abc'&&55);  // 3 "some" 0 "" NaN

        // ||（或） -> || 和 && 相反
        // 倾向返回真的值 -> 如果存在不是布尔值，一旦找到真的立刻返回；直到找不到，返回最后一个。
        console.log(2>1||3, 7||"some", 0||"", ""||0, 22*'abc'||55);  // True, 7, "", 55

        // !
        // !!a 相当于 Boolean(a)
        console.log(!!"", Boolean(""), !!"blue", Boolean("blue"), !!NaN, Boolean(NaN))  // f f t t f f 
    </script>
</body>
</html>